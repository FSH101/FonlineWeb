# FonlineWeb

FonlineWeb — это браузерная MMO по мотивам Fallout 2 с изометрической графикой и многопользовательским взаимодействием. Проект находится на этапе начальной разработки.

## Структура репозитория

- `server/` — серверная часть на TypeScript (Node.js) с поддержкой HTTP API, WebSocket и динамической подгрузкой игровых скриптов.
- `server/game-scripts/` — каталог игровых скриптов, совместимых с системой `include` оригинальной игры.
- `client/` — экспериментальный клиент для визуализации гекс-сетки и отладки перемещений.
- `docks/` — дополнительные материалы и документация.

## Быстрый старт (локально)

```bash
cd server
cp .env.example .env
npm install
npm run dev
```

По умолчанию сервер поднимается на `http://localhost:8080` и обслуживает HTTP API, WebSocket и статический клиент в одном процессе. После запуска откройте `http://localhost:8080` в браузере, чтобы увидеть тестовый интерфейс. Если переменная `DATABASE_URL` не задана, сервер стартует в автономном режиме без подключения к PostgreSQL. Для полноценной интеграции укажите строку подключения в `DATABASE_URL`, а чтобы сделать базу данных обязательной — установите `REQUIRE_DATABASE=true`. Путь к статическим файлам можно переопределить через переменную окружения `PUBLIC_DIR`.

## Гексовая карта и перемещение

Сервер поддерживает прототип игрового мира размером 50×50 гексов в axial-координатах с even-q раскладкой. При подключении по WebSocket игрок автоматически спавнится в центре карты и может перемещаться в шести направлениях. Доступные значения направления: `east`, `northEast`, `northWest`, `west`, `southWest`, `southEast`.

API WebSocket:

- `player:move` — перемещение персонажа. Тело сообщения: `{ "direction": "northEast" }`.
- `player:setName` — переименование персонажа. Тело сообщения: `{ "name": "Имя" }`.

Сервер рассылет широковещательные события `world:*` об изменении состояния мира всем подключённым клиентам.

## Тестовый клиент

В каталоге `client/` находится интерактивный прототип интерфейса: полноэкранная гекс-сцена с HUD поверх поля, включающим компактную панель действий в левом нижнем углу и вытянутый чат вдоль нижнего края. Дополнительные окна (инвентарь, персонаж, карта, настройки, экипировка) появляются поверх игры только по запросу. Во время разработки сервер сам обслуживает файлы из этого каталога — дополнительных настроек не требуется.

Основные возможности прототипа:

- перемещение персонажа кликом или касанием по соседнему гексу с подсветкой текущей позиции;
- дополнительная поддержка управления клавишами `Q`, `W`, `E`, `A`, `S`, `D` для отладки на десктопе;
- чат-заглушка в стиле Fallout, занимающая большую часть нижней панели, и компактный блок действий в левом нижнем углу с обратной связью о нажатиях;
- всплывающие поверх игровой сцены окна-заглушки для инвентаря, карты, персонажа, экипировки и настроек, которые открываются и закрываются по клику по кнопкам панели действий или клавише `Esc`.
- окно «Персонаж» стилизовано под оригинальное меню прицельной атаки Fallout: зелёная голограмма цели в центре, кнопки выбора частей тела по краям и консоль с подсказками в нижней части.

Интерфейс адаптирован под мобильные устройства и сохраняет тёмную Fallout-стилистику (чёрный фон, зелёно-жёлтые акценты).

### Конфигурация интерфейса

Клиент читает внешнюю конфигурацию HUD из файла [`client/ui/default.ini`](client/ui/default.ini). Формат идентичен оригинальным ini-файлам Fallout: `ключ = значение`, секции в квадратных скобках, комментарии начинаются с `#`. На текущем этапе через конфиг можно:

- переименовывать заголовки и подписи панелей в блоках `[Meta]`, `[Chat]`, `[CommandBar]`;
- задавать размеры и отступы HUD числовыми значениями, которые автоматически трактуются как пиксели (например, `Chat.Width = 640`);
- управлять набором кнопок и горячих клавиш панели действий в секциях `Action.*` (`Hotkey = KeyI` и т. п.);
- описывать всплывающие окна в секциях `Overlay.*`, указывая текст и списки заметок через `Notes`;
- настраивать особую разметку окна `Overlay.character`: списки целей (`LeftTargets`/`RightTargets`), подписи монитора (`ConsolePrimary`, `ConsoleSecondary`) и вспомогательные показатели (`ConsoleStats`, `ConsoleFooter`).

За загрузку и парсинг отвечает модуль `client/ui/configLoader.js`. Если файл отсутствует или содержит ошибки, клиент использует встроенную конфигурацию по умолчанию и продолжает работу без перезагрузки.

### Анимация персонажа

Модуль `client/player/assets/manifestRegistry.js` содержит описания тестовых анимаций главного героя из проекта [TLA3.0TG](https://github.com/FSH101/TLA3.0TG) и динамический реестр GIF-анимаций из папки `client/player/assets/critters`:

- `HFCMBTAB` — ходьба в шести направлениях (анимация перемещения);
- `HFCMBTAA` — стойка с микродвижением (анимация ожидания).

Для каждой записи одновременно задаются локальные каталоги `client/player/assets/human_female/HFCMBTAA|HFCMBTAB/dir_0…dir_5` и удалённая резервная база (`https://raw.githubusercontent.com/...`). Каталоги уже созданы в репозитории и содержат только заглушки `.gitkeep` — можно смело складывать туда собственные PNG-кадры, не опасаясь конфликтов при обновлении. При запуске клиент сначала пытается прочитать кадры из локальной папки, а если файлов нет или сервер возвращает 404, происходит автоматический откат к удалённым ресурсам GitHub.

Дополнительно, если рядом с клиентом распаковать набор анимаций в структуру `client/player/assets/critters/<Префикс>__<направление>.gif` (например, из релиза `fr_gifs_pack.zip`), манифесты создаются на лету. Префикс соответствует названию файла FR (например, `HANPWRAA`), а суффиксы направлений интерпретируются следующим образом: `W` — движение к камере (`southEast`), `NW` — фронт-влево (`southWest`), `NE` — левый профиль (`west`), `E` — спина-влево (`northWest`), `S` — спина-вправо (`northEast`), `SW` — правый профиль (`east`). Достаточно указать путь `player/assets/critters/HANPWRAA` в конфиге игрока — клиент сам подберёт нужные GIF.

Кадры PNG преобразуются в `ImageBitmap` и синхронизируются с указанной частотой. На стороне клиента действует единый рендер-цикл (`requestAnimationFrame`), поэтому анимация автоматически подстраивается под частоту обновления экрана.

> ⚠️ **Важно.** В репозитории намеренно игнорируются все бинарные кадры (`*.png`, `*.frm`, архивы и т. п.) внутри `client/player/**` — это зафиксировано в корневом `.gitignore`. Можно смело держать локальные ресурсы для тестов, но не добавляйте их в коммиты.

Модуль `client/player/heroSprite.js` умеет работать как с оригинальными Fallout FR/FRM-файлами, так и с удалёнными PNG. Определение формата происходит автоматически по расширению пути: если указан файл `*.fr(m)`, используется встроенный декодер FR с палитрой Fallout; если передана папка с `manifest.json`, модуль считывает метаданные из каталога; если путь совпадает с ключом из `manifestRegistry`, данные берутся из встроенного описания без чтения диска.

Конфигурация `[Player]` в `client/ui/default.ini` управляет подключением анимаций и поддерживает следующие параметры:

- `RunAnimation` — путь до FR/FRM или каталога с `manifest.json`, содержащего бег персонажа по 6 направлениям;
- `IdleAnimation` — путь до анимации ожидания (формат аналогичен `RunAnimation`). Если не задано, клиент использует ту же последовательность, что и для бега;
- `DirectionOrder` — соответствие индексов направлений и гекс-компаса (по умолчанию `northEast, east, southEast, southWest, west, northWest`);
- `MoveDuration` — длительность перехода между соседними гексами в миллисекундах (определяет интерполяцию);
- `Scale` — коэффициент масштабирования спрайта относительно оригинального PNG/FR кадра;
- `OffsetX` и `OffsetY` — смещения от центра гекса после масштабирования (в пикселях);
- `DefaultFacing` — стартовое направление до получения данных о перемещении.

По умолчанию клиент использует женского персонажа (`RunAnimation = player/assets/human_female/HFCMBTAB`, `IdleAnimation = player/assets/human_female/HFCMBTAA`). Если ресурсы не найдены, система выводит предупреждение в консоль и возвращается к упрощённому маркеру.

## Декодер FR файлов

Для работы с оригинальными анимациями добавлен CLI-скрипт декодирования Fallout FR с применением переданной палитры JASC-PAL. Он извлекает кадры в формате PNG и сохраняет метаданные.

```bash
cd server
npm run decode-fr -- path/to/animation.fr --output ./decoded/animation
```

Опции:

- `--skip-images` — не сохранять PNG-кадры, только метаданные.
- `--skip-metadata` — не сохранять `metadata.json`.
- `-q/--quiet` — отключить подробный вывод.

По умолчанию прозрачность берётся из нулевого индекса палитры, а PNG-файлы группируются по направлениям (`direction_0` ... `direction_5`).

## Docker

Для запуска в контейнере предусмотрен `Dockerfile` в корне репозитория, который собирает сервер и статический клиент в один образ. Пример сборки:

```bash
docker build -t fonlineweb .
```

После сборки контейнер можно запустить командой

```bash
docker run --rm -p 8080:8080 fonlineweb
```

При необходимости передайте `--env DATABASE_URL=...`, чтобы сразу подключить PostgreSQL. Контейнер слушает порт, указанный в переменной окружения `PORT` (по умолчанию `8080`), и отдаёт веб-интерфейс на корневом адресе.

## Развёртывание на Render

В репозитории присутствует файл [`render.yaml`](render.yaml), описывающий единый веб-сервис с Docker-сборкой. Ниже приведён полный сценарий ручного запуска на Render.

### Предварительные требования

- Аккаунт в [Render](https://render.com/) с привязанным репозиторием GitHub/GitLab, в котором доступен проект.
- Опциональная база данных PostgreSQL. Если требуется персистентное хранение, создайте управляемый сервис в Render или используйте внешний хостинг и подготовьте строку подключения `DATABASE_URL`. При отсутствии базы сервер продолжит работу в автономном режиме.
- Значения переменных окружения `DATABASE_URL` (строка подключения к БД) и при необходимости `PUBLIC_DIR`, `PORT` (опционально, по умолчанию Render задаёт `PORT` автоматически).

### Пошаговое руководство

1. **Создайте сервис базы данных (опционально).** В панели Render выберите _New → PostgreSQL_. Задайте имя, регион и тариф. После создания в разделе _Connections_ скопируйте `External Database URL` — это значение нужно будет указать как `DATABASE_URL`.
2. **Добавьте проект в Render.** В панели Render перейдите в _Dashboard → New + → Web Service_. При первом деплое подключите ваш репозиторий GitHub/GitLab, найдите его в списке и выберите.
3. **Подтвердите использование `render.yaml`.** Render обнаружит файл конфигурации и предложит создать инфраструктуру из него. Убедитесь, что в предварительном просмотре выбран сервис `fonlineweb` с типом `web service` и источником `Dockerfile`.
4. **Проверьте параметры сборки.** Для веб-сервиса убедитесь, что:
   - `Runtime` установлен в `Docker` (Render подставит это автоматически);
   - поле **Dockerfile Path** содержит `Dockerfile`. Render по умолчанию подставляет значение `src`; в репозитории добавлена символьная ссылка `src → Dockerfile`, поэтому сборка всё равно завершится успешно, но рекомендуется вручную заменить значение на `Dockerfile`, чтобы избежать неоднозначности в UI;
   - `Docker Build Context Directory` указывает на корень репозитория (`.`). Это значение также зашито в [`render.yaml`](render.yaml) через поле `dockerContext`;
   - `Build Command` — `docker build ...` (Render формирует команду сам на основе `Dockerfile`);
   - `Start Command` пустой — в `Dockerfile` уже задан `CMD`.
5. **Настройте переменные окружения.** Если база данных уже создана, добавьте переменную `DATABASE_URL` со значением строки подключения. Для автономного стенда этот шаг можно пропустить. Дополнительно доступны параметры `PUBLIC_DIR` (кастомный каталог статических файлов) и `REQUIRE_DATABASE=true`, чтобы останавливать контейнер при любой ошибке подключения к БД.
6. **Запустите создание сервиса.** Нажмите _Create Web Service_. Render поставит задачу сборки, построит Docker-образ и развернёт контейнер.
7. **Проверьте логи.** В разделе _Events_ отслеживайте логи сборки и запуска. После строки `Server listening on :PORT` сервис считается доступным.
8. **Проведите smoke-тест.** Откройте выданный Render URL вида `https://<имя-сервиса>.onrender.com`. Должны отображаться гекс-сцена и HUD, WebSocket подключается автоматически. Для проверки API можно выполнить `curl https://<имя-сервиса>.onrender.com/world` — ответ содержит состояние мира.
9. **Настройте автообновления.** По умолчанию Render будет автоматически деплоить новые коммиты в выбранной ветке. При необходимости настройте _Auto Deploy_ или ручной триггер релизов в настройках сервиса.

При изменениях инфраструктуры (например, добавление фоновых воркеров) обновляйте `render.yaml` — Render синхронизирует конфигурацию при следующем деплое.

## План разработки

План и прогресс ведутся в файле [TASKS.md](TASKS.md).

