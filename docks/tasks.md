tasks.md — MVP онлайн-клиента с сервером и выборочной подгрузкой ассетов
0) Что это и как этим пользоваться

Этот документ — единственный источник правды по задачам проекта.

Правило для Codex: в каждом ответе и в каждом PR в начале указывай ссылку на соответствующий раздел tasks.md формата:
REFERENCE: tasks.md §<раздел> / <ID задачи>
Пример: REFERENCE: tasks.md §3.1 / T-S-001

Любая новая задача сначала добавляется сюда (в «Бэклог»), получает ID, только затем выполняется.

1) Контекст и ограничения

Источник ассетов: https://github.com/FSH101/TLA3.0TG ветка codex/define-mvp-architecture-and-requirements-c92mce, директория:
Assets_1/ (далее — «Assets_1»)
Используем FR-декодер (формат FR/FRM), без предварительной конвертации в GIF/PNG на этапе MVP.

Цель MVP: онлайн-демо: несколько клиентов входят на одну карту, двигаются, видят друг друга, открывают двери.

Деплой: один веб-сервис на Render — один процесс, один PORT (HTTP статик + WebSocket).

Код без тяжёлых ассетов в Git: ассеты подтягиваются выборочно из Assets_1.

2) Архитектура (высокоуровнево)

Единый сервис (Docker):

HTTP: отдаёт собранный фронтенд.

WS: обрабатывает соединения, валидирует действия, рассылает состояние.

Клиент (web): Canvas-рендер, управление, сетевой протокол (движение/двери). Логика перемещения и рисования вдохновлена ajxs/jsFO (только идеи рендера/слоёв/цикла).

FR-декодер: модуль, который умеет брать FR/FRM из Assets_1 и отдавать кадры/атласы в рантайме (минимальный набор для MVP).

Выборочная подгрузка ассетов: манифест «что нужно на старте» → подгрузка только перечисленного.

3) План релизов (Milestones)
3.1 M0 — Bootstrap репозитория

Цель: чистый каркас проекта и дисциплина выполнения задач.
Критерии приёмки (DoD):

Создан монорепо со структурами client/, server/, shared/, tools/ (без кода).

Заведен tasks.md (этот файл) в корне.

Настроен CI «lint/check» (минимально) и шаблон PR с полем REFERENCE:.

Задачи:

T-M0-001: Создать базовую структуру репозитория и добавить этот tasks.md.

T-M0-002: Добавить PR-template с требованием поля REFERENCE: tasks.md §… / <ID>.

T-M0-003: Добавить пустые README.md в client/, server/, shared/ с кратким назначением.

3.2 M1 — Сервер: многопользовательское ядро (приоритет №1)

Цель: авторитетный сервер, который держит мир и синхронизирует клиентов.
Критерии приёмки:

Один процесс слушает PORT (HTTP+WS).

Поддержка нескольких клиентов; появление/выход корректно обрабатывается.

Сообщения: hello, move, openDoor; ответы: welcome, state, error.

Сервер валидирует проходимость и дверь (открыта/закрыта), рассылает state.

Логи подключений/ошибок; простая защита от флуд-move (rate-limit).

Задачи:

T-S-001: Спецификация протокола (словами) и фиксация в shared/README (без кода).

T-S-002: Реализовать серверную обработку WS (единый PORT), маршрутизацию сообщений.

T-S-003: Хранение состояния: игроки (id, pos, dir), двери (id, open), карта (минимальная).

T-S-004: Валидация шагов: границы карты, непроходимые клетки, закрытая дверь.

T-S-005: Бродкаст состояния с ограничением частоты (10–15 тиков/сек).

T-S-006: Логи: connect/disconnect, кол-во активных клиентов, ошибки.

3.3 M2 — Клиент: рендер и управление (идеомоторика jsFO)

Цель: увидеть карту, двигаться, кликать дверь и видеть других игроков.
Критерии приёмки:

Рендер тайлов (пол/крыша) и объектов («дверь» как минимум).

Управление: клавиатура/тач-стик → move запросы на сервер.

Клик по двери → openDoor запрос → все клиенты видят новую фазу двери.

Базовая интерполяция между апдейтами сервера (необязательно на МВП, но желательна).

Задачи:

T-C-001: Визуальная модель карты: порядок слоёв, камера, «первый пиксель».

T-C-002: Обработчик ввода (WASD/стрелки/тач) → сетевые команды.

T-C-003: Отрисовка других игроков (простые маркеры/спрайты).

T-C-004: Клик по двери → запрос openDoor.

T-C-005: Базовая интерполяция позиций (по возможности).

3.4 M3 — Ассеты: выборочная подгрузка из Assets_1 + FR-декодер

Цель: не тянуть гигабайты; грузить только нужное сейчас.
Критерии приёмки:

Манифест ассетов MVP в репозитории (текстовый список путей внутри Assets_1).

На сборке/запуске подтягиваются только перечисленные файлы.

FR-декодер умеет декодировать минимальные типы FR/FRM, необходимые для стартовой сцены.

Ошибки загрузки ассетов не валят клиент: есть заглушки/лог.

Задачи:

T-A-001: Определить формат манифеста ассетов assets.manifest.txt (по одному пути на строку; относительные пути внутри Assets_1).

T-A-002: Реализовать выборочную подкачку ассетов из репозитория FSH101/TLA3.0TG (ветка codex/define-mvp-architecture-and-requirements-c92mce, директория Assets_1), строго по списку из манифеста.

T-A-003: Реализовать модуль FR-декодера (минимально: палитра, покадровая анимация, чтение заголовков FR/FRM, рендер в Canvas).

T-A-004: Документация по поддержанным типам FR (тайлы/двери/базовый персонаж), ограничения и тест-кейсы.

Примечание: если для удобства потребуется «тонкий клон» — разрешено использовать sparse-checkout/partial clone по путям из манифеста; но итоговый образ/артефакт должен содержать только нужные файлы.

3.5 M4 — Деплой на Render (один веб-интерфейс)

Цель: один URL, один сервис.
Критерии приёмки:

Приложение слушает process.env.PORT (по умолчанию Render = 10000).

HTTP отдаёт фронт, WS работает на том же хосте/порту.

Билд стабильно проходит; старт без 404/ошибок в консоли.

Задачи:

T-D-001: Подготовить Dockerfile под единый сервис (без включения больших ассетов).

T-D-002: Проверить, что фронт билдится в папку, обслуживаемую сервером.

T-D-003: Прописать в README шаги деплоя и переменные окружения.

3.6 M5 — Качество, устойчивость, бэклог

Критерии приёмки (минимум):

Смоук-тест: 2 вкладки → синхронное движение и дверь.

Переподключение WS без перезагрузки страницы.

Простая телеметрия (логи) и ограничение частоты команд.

Задачи:

T-Q-001: Добавить простые e2e-чек-листы для ручной проверки.

T-Q-002: Обработать типовые ошибки загрузки (ассеты/WS).

T-Q-003 (бэклог): Персист в файл/kv (не для MVP).

T-Q-004 (бэклог): CDN манифест ассетов и ленивые загрузки.

4) Протокол взаимодействия (словами, без кода)

Клиент → Сервер:
hello (инициализация), move (направление), openDoor (doorId).

Сервер → Клиент:
welcome (вы и снимок карты), state (позиции игроков, состояния дверей), error (код+сообщение).

Правило: клиент не меняет своё состояние сам, только по state от сервера.

5) Политика ассетов (MVP)

Где брать: только из Assets_1 указанной ветки и репозитория.

Что брать: только файлы, перечисленные в assets.manifest.txt (лежит в корне нашего проекта).

Когда брать: на этапе сборки/старта — узкий набор для стартовой сцены.

FR-декодер: минимум, чтобы отрисовать тайлы пола/крыши, дверь и один базовый спрайт игрока. Остальные типы — позже.

Запрещено: тащить весь Assets_1 целиком; коммитить ассеты в наш Git.

6) Определения готовности (DoR) и готовности к приёмке (DoD)

DoR задачи: есть ID, цель в одном предложении, входы/выходы, критерии приёмки, и ссылка REFERENCE: tasks.md.

DoD задачи: PR смёржен, ручной смоук пройден, лог/скрин приёмки приложен.

7) Формат отметок о выполнении

В этом файле напротив каждой задачи ставить чек-бокс:

[ ] — не начато

[~] — в работе

[x] — выполнено (с датой и PR)

В PR-описании обязательно поле:
REFERENCE: tasks.md §<раздел> / <ID>

8) Текущий статус (заполняется по мере работы)

M0:

 T-M0-001

 T-M0-002

 T-M0-003

M1:

 T-S-001

 T-S-002

 T-S-003

 T-S-004

 T-S-005

 T-S-006

M2:

 T-C-001

 T-C-002

 T-C-003

 T-C-004

 T-C-005

M3:

 T-A-001

 T-A-002

 T-A-003

 T-A-004

M4:

 T-D-001

 T-D-002

 T-D-003

M5:

 T-Q-001

 T-Q-002

 T-Q-003

 T-Q-004

9) Примечания по реализации (важно, но без кода)

Render: приложение обязано слушать process.env.PORT; WS — на том же домене/порту.

Производительность: ограничивать частоту клиентских move; сервер агрегирует и шлёт дельты 10–15/сек.

Резерв: при недоступности отдельных ассетов FR — показывать заглушки, логировать путь из манифеста.

Риск-менеджмент: FR-декодер делать модульным, чтобы позже заменить на WASM без ломки API.
